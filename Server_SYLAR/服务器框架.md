#sylar
看到P77
LogIniter LogDefined及其与string之间的相互转换，作用是什么？？？
需要学习gdb调试运行中的程序

## 开发环境
centos7
gcc 9.1
cmake

文件路径 /home/sylar/workspace/sylar
sylar目录下 
bin -- 二进制
build -- 中间生成路径
cmake -- cmake函数文件夹
CMakeLists.txt -- cmake的定义文件
lib -- 库的输出路径 
Makefile 
sylar 源代码路径
tests 测试代码路径  



## 日志系统
1）
    Log4J

    Logger(定义日志类别)
        |
        |-------Formatter（日志格式）
        |
    Appender(日志输出地方)

## 线程库
Thread Mutex

pthread pthread_create

互斥量 mutex
信号量 semaphore

和log来整合

Logger Appender  
formatter

SpinLock 替换互斥量，提升写文件性能
写文件 周期性 reopen 

## 协程库封装
定义协程接口
ucontext_t
macro
```
Fiber::GetThis()
Thread->main_fiber <----------> sub_fiber
            ^
            |
            |
            v
          sub_fiber
```
协程调度模块scheduler
```
        1    -N         1-M
scheduler -->thread --- >  fiber
1、线程池，分配一组线程
2、协程调度器，将协程，指定到相应的线程上去执行


N : M

threads
<function<void()>,fiber,thread>m_fibers

schedule(func/fiber)

start()
stop()
run()
{
    设置当前线程的scheduler
    设置当前线程的run，fiber
    协程调度循环while（true）
        协程消息队列里面是否有任务
        无任务，执行idle方法
}

```

```
IOManager (epoll) --> Scheduler
    |
    |
    v
    idle(epoll_wait)


    信号量
PutMessage(msg,) + 信号量1,single()

message_queue
    |
    |----Thread
    |----Thread
        wait()-信号量1，RecvMessage(msg,)


异步IO，等待数据返回。epoll_wait等待

epoll_create\epoll_ctl\epoll_wait

```

查看进程在干什么？ gdb attach 进程号


```
Timer -> addTimer() -->cancel()
获取当前定时器触发离现在的时间差
返回当前需要触发的定时器
```

```
        [Fiber]                  [Timer]
           ^  N                     ^
           |                        |
           |  1                     |      
        [Thread]              [Timermanager]
           ^  M                     ^
           |                        |
           |  1                     |
        [Scheduler] <------- [IOmanager(epoll)]


```

## HOOK
sleep,
usleep,

socket 相关的（socket、connect、accept）
io相关（read、write、send、recv，。。。）
fd相关（fcntl，ioctl，。。。）

## socket函数库
            
connect accept read/write/close


                [Socket]
                    |
                --------                    |-[IPv4Address] 
                [Address] --- [IPAddress] --|   
                ---------                   |-[IPv6Address]
                    |
                [UnixAddress]

## 序列化bytearray
write(int floor int64 ,...)
read(int floor int64 ,...)

## http协议开发
HTTP/1.1 - API

HttpRequest;
HttpResponse;

GET / HTTP/1.1
Host: www.sylar.top

HTTP/1.0 200 OK
Pragma: no-cache
Content-Type: tex/html
Content-Length: 14988
Connection:close

utl: http://www.sylar.top:80/page/xxx?id=10&v=20#fr
    http ,协议
    www.sylar.top,host
    80 端口
    /page/xxx,path
    id=10&v=20 param
    fr fragment

ragel 解析 
指令：在http目录下
//相关网址 
https://www.githubs.cn/projects/205878561-colm

https://blog.csdn.net/weixin_43798887/article/details/116100949
ragel -G2 -C http11_parser.rl -o http11_parser.cc

备注：http11_parser.rl.cc 以及httpclient_parser.rl.cc 头文件解决方法在P64中16:43前后有处理
parser解析

## TCPServer封装
基于TCPServer实现一个EchoServer
## STREAM封装 针对文件、socket封装
read/write/readFixSize/writeFixSize

HttpSeession/HttpConnection
Server.accept ,socket -> session
client connect socket -> Connection

HttpServer : TcpServer
P71 29:25秒有gdb调试信息，可以了解一下

        Servlet <------ FuntionServlet
            |
            |
            v
        ServletDispatch
        


## 分布协议

## 推荐系统






