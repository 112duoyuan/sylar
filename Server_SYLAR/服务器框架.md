#sylar

## 开发环境
centos7
gcc 9.1
cmake

文件路径 /home/sylar/workspace/sylar
sylar目录下 
bin -- 二进制
build -- 中间生成路径
cmake -- cmake函数文件夹
CMakeLists.txt -- cmake的定义文件
lib -- 库的输出路径 
Makefile 
sylar 源代码路径
tests 测试代码路径  



## 日志系统
1）
    Log4J

    Logger(定义日志类别)
        |
        |-------Formatter（日志格式）
        |
    Appender(日志输出地方)

2）配置系统

Config --> Yaml 


yamp-cpp:github 
mkdir build && cd build &&cmake .. && make install
```cpp
YAML::Node nodeLoadFile(filename);
node.IsMap()
for(auto it = node.begin();
    it != node.end(); ++it){
        it->first,it->second
}

node.IsSequence()
for(size_t i ...)
```

配置系统的原则，约定优于配置
```cpp
template<T,FromStr,ToStr>
class ConfigVar;

template<F,T>
LexicalCast;

//容器偏特化，目前支持vector
//list map set unordered_map unordered_set
//map/unordered_set 支持key = std:string
// Config::Lookup(key) ,key相同
//类型不同、不会有报错、需要处理一下
```

自定义类型，需要实现sylar::LexicalCast 偏特化
实现后就可以支持Config解析自定义类型，自定义类型可以和容器实现

配置事件机制
当一个配置项发送修改的时候，可以反向通知对应的代码，回调

#日志系统整合配置系统
```cpp
logs:
    - name: root
      level: (debug,info,warn,error,fatal)
      formatter: '%d%T%pT%t%m%n'
      appender:
        - type: (StdoutLogAppender,FileLogAppender)
          level:(debug,...)
          file: /logs/xxx.log
```
```cpp
    sylar::Logger g_logger = 
    sylar::LoggerMgr::GetInstance()->getLogger(name);
    SYLAR_LOG_INFO(g_logger) << "xxx log";
```

```cpp
static Logger::ptr g_log = SYLAR_LOG_NAME("system");
//m_root,m_system->m_root 当logger的appender为空，使用root写logger

```
## 协程库封装

## socket函数库

## http协议开发

## 分布协议

## 推荐系统






